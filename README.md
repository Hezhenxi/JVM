# JVM 内存模型 :see_no_evil:

## 目录


<a name="3060-1621846615933"></a><a name="ljl3-1699839632592"></a>[一.java虚拟机发展史](#rbsx-1677787866415)

<a name="bq8y-1699839632594"></a>[- 一次编译，处处运行。jvm运行在不同平台上](#qus2-1642581585652)

<a name="nuvi-1699839632596"></a>[-openJDk(与 jdk 80%相同度)](#igm6-1642581657102)

<a name="h4mk-1699839632598"></a>[-VM HotSpot 、](#meoe-1699839026850)

<a name="jwnj-1699839632600"></a>[-GraalVM](#ax00-1699839028147)

<a name="7dyp-1699839632602"></a>[二.java内存区域与内存溢出异常](#rssr-1677787866416)

<a name="v5wd-1699839632604"></a>[1.堆内存溢出（Heap Overflow）：](#jm09-1699839405243)

<a name="mu0n-1699839632606"></a>[2.栈内存溢出（Stack Overflow）：](#kzmx-1699839405610)

<a name="frue-1699839632608"></a>[3.永久代/元空间溢出（PermGen/Metaspace Overflow）：](#mvhy-1699839405611)

<a name="vulg-1699839632610"></a>[4.方法区溢出（Method Area Overflow）：](#tkl8-1699839405612)

<a name="sqit-1699839632612"></a>[5.堆栈溢出（Heap and Stack Overflow）：](#ywuv-1699839405613)

<a name="7x1h-1699839632614"></a>[6.直接内存溢出（Direct Memory Overflow）：](#kfqc-1699839405614)

<a name="zaeb-1699839632616"></a>[2.OutOfMemeoryError异常](#qezx-1677787866417)

<a name="v0fm-1699839632618"></a>[2.4.1 java堆溢出](#z20k-1677787866418)

<a name="tn95-1699839632620"></a>[2.4.2 虚拟机栈和本地方法栈溢出](#d5ps-1677787866419)

<a name="erfg-1699839632622"></a>[2.4.3 方法区和运行时常量池溢出](#sid6-1677787866420)

<a name="cbtv-1699839632624"></a>[三.垃圾收集器与内存分配策略](#sfbq-1677787866421)

<a name="icdt-1699839632626"></a>[-数据类型：  ](#ze8c-1677787866422)

<a name="a9n6-1699839632628"></a>[1.基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress     ](#uv32-1645624587455)

<a name="hty1-1699839632630"></a>[2.引用类型：类，接口，数组          ](#k7qk-1645624643695)

<a name="g63i-1699839632632"></a>[-堆和栈：](#hxcn-1677787866423)

<a name="gyri-1699839632634"></a>[1.栈是运行时单位：栈解决程序运行问题，即程序如何执行，或者说如何处理数据；](#fsep-1645622991795)

<a name="vyol-1699839632636"></a>[2.堆是存储单位：堆解决数据存储问题，即数据怎么放，放在哪儿。](#huzb-1645623058991)

<a name="sdur-1699839632638"></a>[-值传递：copy 实参值给 形参](#mmwq-1677785583112)

<a name="vys6-1699839632640"></a>[-引用传递：copy 实参对象地址(引用地址) 给 形参](#bb7u-1677785615712)

<a name="l7b2-1699839632642"></a>[-Java对象大小：](#bqbm-1677787866425)

<a name="yhzt-1699839632644"></a>[-引用类型：](#isun-1677787866426)

<a name="rhev-1699839632646"></a>[1.强引用:](#niel-1645705756361)

<a name="plrg-1699839632648"></a>[2.软引用:](#p0w9-1645705756361)

<a name="5jza-1699839632650"></a>[3.弱引用:](#e82t-1645705756361)

<a name="0fmr-1699839632652"></a>[4.虚引用](#4yx3-1645705756361)

<a name="gsx6-1699839632654"></a>[3.63.内存分配策略](#9eet-1677787866427)

<a name="4zrd-1699839632656"></a>[四.虚拟机性能监控与故障处理工具](#dvpe-1677787866428)

<a name="gxdk-1699839632658"></a>[4.1 java/bin ](#xr51-1677787866429)

<a name="ornp-1699839632660"></a>[五.调优案例分析与实战](#nqid-1677787866430)



<a name="rbsx-1677787866415"></a>**一.java虚拟机发展史**

<a name="qus2-1642581585652"></a>**- 一次编译，处处运行。jvm运行在不同平台上**

<a name="igm6-1642581657102"></a>**-openJDk(与 jdk 80%相同度)**

<a name="meoe-1699839026850"></a>**-VM HotSpot 、**

<a name="ax00-1699839028147"></a>**-GraalVM**

<a name="rssr-1677787866416"></a>**二.java内存区域与内存溢出异常**

<a name="rk8p-1645509750991"></a>TPS Throughput    吞吐量

<a name="otzf-1645509755030"></a>QPS   Query Per Second   每秒查询数 （特定场景的 吞吐量）

<a name="jm09-1699839405243"></a>**1.堆内存溢出（Heap Overflow）：**

<a name="yooe-1699839265336"></a>原因：堆内存中的对象过多或对象占用的内存过大，导致堆空间不足。

<a name="0k81-1699839265338"></a>场景：创建大量的对象、对象保留时间过长、对象持有大量数据等。

<a name="kzmx-1699839405610"></a>**2.栈内存溢出（Stack Overflow）：**

<a name="4r8f-1699839265342"></a>原因：方法调用的层级过深，导致栈空间不足。

<a name="hr12-1699839265344"></a>场景：递归调用、方法调用层级过深等。

<a name="mvhy-1699839405611"></a>**3.永久代/元空间溢出（PermGen/Metaspace Overflow）：**

<a name="hzkx-1699839265348"></a>原因：持续不断地加载类或创建大量动态生成的类，导致永久代/元空间不足。

<a name="llag-1699839265350"></a>场景：大量动态生成的类（如动态代理、动态生成字节码等）或持续不断的类加载。

<a name="tkl8-1699839405612"></a>**4.方法区溢出（Method Area Overflow）：**

<a name="wnie-1699839265354"></a>原因：持续不断地加载类或创建大量动态生成的类，导致方法区不足。

<a name="jcdx-1699839265356"></a>场景：大量动态生成的类（如动态代理、动态生成字节码等）或持续不断的类加载。

<a name="ywuv-1699839405613"></a>**5.堆栈溢出（Heap and Stack Overflow）：**

<a name="rhqd-1699839265360"></a>原因：同时发生堆内存溢出和栈内存溢出。

<a name="i04i-1699839265362"></a>场景：递归调用的方法中创建大量对象，同时栈空间不足。

<a name="kfqc-1699839405614"></a>**6.直接内存溢出（Direct Memory Overflow）：**

<a name="dnbg-1699839265366"></a>原因：使用了大量的直接内存，而没有及时释放，导致直接内存不足。

<a name="upu2-1699839265368"></a>场景：使用了NIO（New I/O）库或Unsafe类等直接操作内存的方式。

<a name="fzsr-1645498019561"></a><a name="qezx-1677787866417"></a>**2.OutOfMemeoryError异常**

<a name="z20k-1677787866418"></a>**2.4.1 java堆溢出**

<a name="akvb-1642582371685"></a>不断创建对象，并且保证GC Roots到对象之间有可达路径（reachable）来避免垃圾回收机制清除这些对象。对象数量到达最大堆的容量限制后就会产生内存溢出异常

<a name="ku85-1642582508658"></a>堆最小值 -Xms  最小堆内存/(初始堆内存)，即应用启动后分配的内存。

<a name="1sgr-1645509409677"></a>最大值 -Xmx    最小堆内存满后，可扩展的最大值

<a name="t4za-1645704336238"></a>栈大小 -Xss   栈溢出 stackoverflow   通常是无法返回的递归

<a name="h2xg-1642582563670"></a>通过参数-xx:+HeapDumpOnOutMemoryError     开启内存溢出时Dump当前内存堆转储快照。

<a name="yyjd-1642582666480"></a>  Java heap space 是常见的内存溢出异常

<a name="d5ps-1677787866419"></a>**2.4.2 虚拟机栈和本地方法栈溢出**

<a name="sid6-1677787866420"></a>**2.4.3 方法区和运行时常量池溢出**

<a name="sfbq-1677787866421"></a>**三.垃圾收集器与内存分配策略**

![截图.png](assets/Aspose.Words.c7af42fb-21ee-4bc6-9a37-bd7928102919.001.png)

<a name="rodz-1645703345277"></a><a name="tyau-1677787866446"></a><a name="ze8c-1677787866422"></a>**-数据类型：**  

<a name="uv32-1645624587455"></a>**1.基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress**     

<a name="k7qk-1645624643695"></a>**2.引用类型：类，接口，数组**          

<a name="ghpz-1645622913860"></a>new 对象/实例  赋给 对象的引用p     Person p = new Person("me");

<a name="nkjk-1645498641577"></a>一个对象/实例 可以有多个引用， 一个引用（p）只能绑定0或1个对象。

<a name="hxcn-1677787866423"></a>**-堆和栈：**

<a name="fsep-1645622991795"></a>**1.栈是运行时单位：栈解决程序运行问题，即程序如何执行，或者说如何处理数据；**

<a name="h8xy-1645703618769"></a>不同线程执行逻辑有所不同，因此需要一个独立的线程栈（栈帧），数据包含局部变量、程序运行状态，方法返回地址等。

<a name="sijn-1645703657904"></a>存什么？

<a name="zgdp-1645703682678"></a>包括基本数据类型(1~8 byte)  1byte = 8bit

<a name="1sbl-1645703748680"></a> 堆中对象的引用（4 byte）

<a name="huzb-1645623058991"></a>**2.堆是存储单位：堆解决数据存储问题，即数据怎么放，放在哪儿。**

<a name="gpkk-1645703103828"></a>而堆则是所有线程共享的，只负责存储对象信息。

![截图.png](assets/Aspose.Words.c7af42fb-21ee-4bc6-9a37-bd7928102919.002.png)

![截图.png](assets/Aspose.Words.c7af42fb-21ee-4bc6-9a37-bd7928102919.003.png)

![截图.png](assets/Aspose.Words.c7af42fb-21ee-4bc6-9a37-bd7928102919.004.png)

<a name="xx7f-1677787866447"></a><a name="tjhc-1677787866448"></a><a name="tasb-1677787866449"></a><a name="mmwq-1677785583112"></a>**-值传递：copy 实参值给 形参**

<a name="bb7u-1677785615712"></a>**-引用传递：copy 实参对象地址(引用地址) 给 形参**

<a name="zofp-1677785511227"></a>**面向对象就是堆和栈的完美结合:**对象的属性其实就是数据，存放在堆中；而对象的行为（方法）即运行逻辑，则放在栈中。（Main函数就是栈的起点，也是程序的入口）

<a name="y8qp-1645703931899"></a>  java 程序运行永远都是在栈中进行的，因而传递参数时，只存在传递基本类型和对象引用问题。不会直接传对象本身。

<a name="mfxe-1645704941567"></a>基本类型和引用的处理是一样的，都是传值；形参传的都是值的副本，只不过引用传递传的堆地址副本，与原值地址都是指向的同一实例对象。

<a name="swfu-1645791880837"></a>当进入被调用方法时，被程序解释（查找）到堆中的对象，这个时候才对应到真正的对象，修改的时堆中的数据。

<a name="smss-1645704529863"></a>可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树（即非叶子节点），基本类型则为树的叶子节点

<a name="bqbm-1677787866425"></a>**-Java对象大小：**

<a name="onqk-1645704643621"></a>一个空Object对象的大小是8byte.

<a name="9sng-1645704571017"></a>Object ob = new Object();  所占空间为  ob  **4byte +  8byte** new Object       所有对象都要继承 object 对象 ，所以无论什么样的java对象都大于8byte

Class NewObject {

`    `int count;

`    `boolean flag;

`    `Object ob;

}

`    `其大小为：空对象大小(8byte)+int大小(4byte)+Boolean大小(1byte)+空Object引用的大小(4byte)=17byte。

`    `但是因为Java在对对象内存分配时都是以8的整数倍来分，因此大于17byte的最接近8的整数倍的是24，因此此对象的大小为24byte。



<a name="pkfu-1645705143449"></a>    注意：包装类型至少是12Byte (声明一个空object至少需要的空间)，分配为16Byte,是基本类型的N倍。自动拆装箱使虚拟机在存储方面进行优化。

<a name="isun-1677787866426"></a>**-引用类型：**

<a name="nora-1645705739486"></a>对象引用类型分为**强引用、软引用、弱引用和虚引用。**

<a name="niel-1645705756361"></a>**1.强引用:**

<a name="fipd-1699839543666"></a>就是我们一般声明对象是时虚拟机生成的引用，强引用环境下，垃圾回收时需要严格判断当前对象是否被强引用，如果被强引用，则不会被垃圾回收

<a name="p0w9-1645705756361"></a>**2.软引用:**

<a name="fkea-1699839544764"></a>软引用一般被做为缓存来使用。与强引用的区别是，软引用在垃圾回收时，虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收。如果剩余内存比较紧张，则虚拟机会回  收软引用所引用的空间；如果剩余内存相对富裕，则不会进行回收。换句话说，虚拟机在发生OutOfMemory时，肯定是没有软引用存在的。

<a name="e82t-1645705756361"></a>**3.弱引用:**

<a name="oarh-1699839547405"></a>弱引用与软引用类似，都是作为缓存来使用。但与软引用不同，弱引用在进行垃圾回收时，是一定会被回收掉的，因此其生命周期只存在于一个垃圾回收周期内。

<a name="6taa-1645705756361"></a>强引用不用说，我们系统一般在使用时都是用的强引用。而“软引用”和“弱引用”比较少见。他们一般被作为缓存使用，而且一般是在内存大小比较受限的情况下做为缓存。因为如果内存足够大的话，可以直接使用强引用作为缓存即可，同时可控性更高。因而，他们常见的是被使用在桌面应用系统的缓存。

<a name="4yx3-1645705756361"></a>**4.虚引用**

<a name="4fai-1699839531314"></a>可以从不同的的角度去划分垃圾回收算法：

<a name="9eet-1677787866427"></a>**3.63.内存分配策略**

![截图.png](assets/Aspose.Words.c7af42fb-21ee-4bc6-9a37-bd7928102919.005.png)

<a name="xwjo-1642586026453"></a><a name="5xqw-1677787866450"></a><a name="d9v1-1642586143712"></a><a name="dvpe-1677787866428"></a>**四.虚拟机性能监控与故障处理工具**

<a name="xr51-1677787866429"></a>**4.1 java/bin** 

<a name="mo4w-1642667852501"></a>工具应用demo

<a name="pece-1645498534936"></a><a name="nqid-1677787866430"></a>**五.调优案例分析与实战**

